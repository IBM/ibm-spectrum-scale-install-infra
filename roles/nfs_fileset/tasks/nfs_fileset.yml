---

##################### Fileset For CES Nodes #####################

# First verifing if fileset already exists if not then creating Independent fileset linking it and printing it.

- name: storage | Find existing filesystem(s)
  shell: /usr/lpp/mmfs/bin/mmlsfs all -Y | grep -v HEADER | cut -d ':' -f 7 | uniq
  register: scale_storage_existing_fs
  changed_when: false
  failed_when: false

- name: Debug the Filesystem name
  debug:
    var: scale_storage_existing_fs.stdout
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Check if fileset in file system already exists
  shell: "/usr/lpp/mmfs/bin/mmlsfileset {{ scale_storage_existing_fs.stdout }} | tail -n +3 | awk '{print $1}' | grep -w {{ item.key }}"
  loop: "{{ scale_protocols.filesets | dict2items }}"
  register: filesets_result
  ignore_errors: yes
  failed_when: filesets_result.rc == 2
  when: is_admin_node | default(false) == true

- name: Print return code for each fileset
  debug:
    msg: "Fileset {{ item.item.key }} - Return Code: {{ item.rc }}"
  loop: "{{ filesets_result.results }}"
  loop_control:
    loop_var: item
  when: is_admin_node | default(false) == true

- name: Create new fileset
  shell: "/usr/lpp/mmfs/bin/mmcrfileset {{ scale_storage_existing_fs.stdout }} {{ item.item.key }} --inode-space new"
  loop: "{{ filesets_result.results }}"
  register: created_fileset
  when: is_admin_node | default(false) == true and item.rc != 0
  run_once: true

- name: Print return code for created filesets
  debug:
    msg: "Fileset_created {{ item.item.item.key }} - Return Code: {{ item.item.rc }}"
  loop: "{{ created_fileset.results }}"
  loop_control:
    loop_var: item
  when: is_admin_node | default(false) == true

- name: Link new fileset
  shell: "/usr/lpp/mmfs/bin/mmlinkfileset {{ scale_storage_existing_fs.stdout }} {{ item.item.item.key }} -J {{ scale_protocols.mountpoint }}/{{ item.item.item.key }}"
  loop: "{{ created_fileset.results }}"
  when: is_admin_node | default(false) == true and item.changed == true
  run_once: true

- name: Check filesets in file system
  command: /usr/lpp/mmfs/bin/mmlsfileset {{ scale_storage_existing_fs.stdout }}
  register: filesets
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Debug the filesets in file system
  debug:
    var: filesets.stdout_lines
  ignore_errors: yes
  when: is_admin_node | default(false) == true

# Setting up quota for filesets

- name: Check quota is already enabled
  shell: "/usr/lpp/mmfs/bin/mmlsfs fs1 -Y | grep -w 'quotasAccountingEnabled' | grep -w 'user;group;fileset'"
  register: enable_quota_check
  loop: "{{ scale_protocols.filesets | dict2items }}"
  ignore_errors: yes
  failed_when: enable_quota_check.rc == 2
  when: is_admin_node | default(false) == true and item.value > 0

- name: Debug to check it quota is already enabled
  debug: 
    msg: "Command to check if quota is already enabled: {{ item.0.cmd }}"
  ignore_errors: yes
  with_together: 
    - "{{ enable_quota_check.results }}"
    - "{{ scale_protocols.filesets | dict2items }}"
  when: is_admin_node | default(false) == true and item.1.value > 0

- name: Run mmchfs command and enable quota
  shell: "/usr/lpp/mmfs/bin/mmchfs {{ scale_storage_existing_fs.stdout }} -Q yes --perfileset-quota"
  register: enable_quota
  loop: "{{ enable_quota_check.results }}"
  run_once: true
  when: is_admin_node | default(false) == true and item.item.value > 0 and item.rc != 0

- name: Run mmcheckquota command
  shell: "/usr/lpp/mmfs/bin/mmcheckquota {{ scale_storage_existing_fs.stdout }}"
  register: quota_check
  loop: "{{ enable_quota_check.results }}"
  run_once: true
  when: is_admin_node | default(false) == true and item.changed == true

- name: Debug the mmcheckquota command
  debug:
    msg: "mmcheckquota Check: {{ item.stdout_lines }}"
  ignore_errors: yes
  loop: "{{ quota_check.results }}"
  when: is_admin_node | default(false) == true and item.changed == true

- name: Debug fileset and quota to be set for it.
  debug:
    msg: "{{ item.key }}: {{ item.value }}GB"
  loop: "{{ scale_protocols.filesets | dict2items }}"
  ignore_errors: yes
  when: is_admin_node | default(false) == true and item.value > 0

- name: Check if quota for fileset is already set
  shell: "/usr/lpp/mmfs/bin/mmlsquota -j {{ item.item.item.key }} -Y {{ scale_storage_existing_fs.stdout }} | grep -v HEADER | cut -d ':' -f 13"
  loop: "{{ created_fileset.results }}"
  register: existing_quota_details
  ignore_errors: yes
  when: is_admin_node | default(false) == true and item.item.item.value > 0

- name: Debug if quota for fileset is already set
  debug:
    msg: "Fileset name: {{ item.item.item.item.key }}  Quota allocated: {{ item.stdout }}"
  loop: "{{ existing_quota_details.results }}"
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Run mmsetquota command
  shell: "/usr/lpp/mmfs/bin/mmsetquota {{ scale_storage_existing_fs.stdout }}:{{ item.item.item.item.key }} --block {{ (item.item.item.item.value * 0.8) | int }}g:{{ item.item.item.item.value }}g"
  loop: "{{ existing_quota_details.results }}"
  register: set_quota
  when: is_admin_node | default(false) == true and item.item.item.item.value > 0 and item.stdout | int == 0

- name: Run mmlsquota command
  shell: "/usr/lpp/mmfs/bin/mmlsquota -j {{ item.item.item.item.item.key }} {{ scale_storage_existing_fs.stdout }}"
  loop: "{{ set_quota.results }}"
  register: quota_details
  ignore_errors: yes
  when: is_admin_node | default(false) == true and item.item.item.item.item.value > 0

- name: Debug the after setting quota
  debug:
    msg: "{{ item.stdout_lines }}"
  loop: "{{ quota_details.results }}"
  ignore_errors: yes
  when: is_admin_node | default(false) == true and item.item.item.item.item.item.value > 0

# Cheking if Auth is already setup if not then Setting up Auth

- name: Check service is already exists
  shell: "/usr/lpp/mmfs/bin/mmuserauth service check | grep -q 'File configuration is USER-DEFINED'"
  register: service_result
  ignore_errors: yes
  failed_when: service_result.rc == 2
  when: is_admin_node | default(false) == true

- name: Service Check Result
  debug:
    var: service_result.rc
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Setup Auth
  shell: "/usr/lpp/mmfs/bin/mmuserauth service create --data-access-method file --type userdefined"
  when: is_admin_node | default(false) == true and service_result.rc != 0
  run_once: true

# Checking if NFS export list if already exists if not then Creating NFS export.

- name: Check NFS export list if already exists
  shell: "/usr/lpp/mmfs/bin/mmnfs export list -Y | tail -n +2 | awk -F: '{print $7, $8}' | sort -k2 | awk '{print $1}' | grep -w {{ scale_protocols.mountpoint }}/{{ item.key }}"
  loop: "{{ scale_protocols.filesets | dict2items }}"
  register: export_list_exists
  failed_when: export_list_exists.rc == 2
  when: is_admin_node | default(false) == true
  ignore_errors: yes
  run_once: true

- name: Print return code of NFS export list
  debug:
    msg: "Export_list {{ item.item.key }} - Return Code: {{ item.rc }}"
  loop: "{{ export_list_exists.results }}"
  loop_control:
    loop_var: item
  when: is_admin_node | default(false) == true

- name: Create NFS export
  shell: '/usr/lpp/mmfs/bin/mmnfs export add {{ scale_protocols.mountpoint }}/{{ item.item.key }} --client "{{ compute_subnet_cidr }}(Access_Type=RW,SQUASH=no_root_squash)"'
  with_items: "{{ export_list_exists.results }}"
  register: created_nfs_export
  when: is_admin_node | default(false) == true and item.rc != 0
  run_once: true

- name: Check NFS export list
  command: /usr/lpp/mmfs/bin/mmnfs export list
  register: export_list
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Debug the NFS export list
  debug:
    var: export_list.stdout_lines
  ignore_errors: yes
  when: is_admin_node | default(false) == true

- name: Change MINOR_VERSIONS
  shell: "/usr/lpp/mmfs/bin/mmnfs config change MINOR_VERSIONS=0,1"
  register: change_minor_versions
  with_items: "{{ export_list_exists.results }}"
  when: is_admin_node | default(false) == true and item.rc != 0
  run_once: true